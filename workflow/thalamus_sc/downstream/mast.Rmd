---
title: "Differential splicing analysis"
author: "Mira Sohn"
output:
    html_document:
        code_folding: hide
        df_print: paged
        toc: true
        toc_float: true
        toc_depth: 3
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(warning=FALSE,
                      message=FALSE,
                      cache.lazy=FALSE)
```

Last run: `r date()`

This workflow is designed to conduct differential splicing (DS) analysis
using [MAST](https://genomebiology.biomedcentral.com/articles/10.1186/s13059-015-0844-5).

Refer to the following resources for technical details:

- [Documentation](https://rglab.github.io/MAST/index.html)
- [GitHub](https://github.com/RGLab/MAST/)

```{r libraries}
# Libraries
library(parallel)
library(tidyverse)
library(ggplot2)
library(reticulate)
library(parallel)
library(yaml)
library(reshape2)
library(limma)
library(NMF)
library(MAST)
library(RColorBrewer)

# Additional options
set.seed(1772)
source('../config/helpers.R')

# Specify the number of available cores
n_cores <- future::availableCores()
options(mc.cores=n_cores)
```

```{r config}

# --------------------------------------------------------------------------------
# This chunk specifies input paths and variables in R
# --------------------------------------------------------------------------------

# Path to input matrix
mtx_path <- "../results/junction_counts/thalamus_sc_perind_numers.counts.gz"

# Path to metadata table
meta_path <- "../results/barcodes.tsv"

# Path to Snakemake config
snakemake_config <- "../config/config.yaml"

# Paths to AnnData
adata_paths <- read_yaml(snakemake_config)[['adata']] %>%
    map(~paste0("../", .x))

# Path to output directory
out_dir <- "ds"

# Create directories if missing
for (p in c(out_dir)) {
    if (! dir.exists(p)) { dir.create(p, recursive=TRUE) }
}

# Specify metadata columns for factors and factor levels
factor_groups <- list(
    general_disease=c('Control', 'FTD', 'AD'),
    celltype=c('ExNeu1', 'ExNeu2'),
    study=c('Marsan', 'Biogen', 'Mathys'),
    study_specific_disease_specific=c('Control-Marsan',
                                      'Control-Biogen',
                                      'Control-Mathys',
                                      'FTD-Marsan',
                                      'FTD-Biogen',
                                      'AD-Mathys'),
    study_disease_specific_celltype=c('Control-Marsan_ExNeu1',
                                      'Control-Marsan_ExNeu2',
                                      'Control-Biogen_ExNeu1',
                                      'Control-Biogen_ExNeu2',
                                      'Control-Mathys_ExNeu1',
                                      'Control-Mathys_ExNeu2',
                                      'FTD-Marsan_ExNeu1',
                                      'FTD-Marsan_ExNeu2',
                                      'FTD-Biogen_ExNeu1',
                                      'FTD-Biogen_ExNeu2',
                                      'AD-Mathys_ExNeu1',
                                      'AD-Mathys_ExNeu2')
)

```

```{python ppackages}
import anndata as ad
import pandas as pd
import numpy as np
import subprocess
import os
```


# Loading input data {.tabset}

The number of splicing junctions was counted based on cellranger-aligned reads and prepared as a 
junction-by-barcode matrix.


```{python import_adata}

# --------------------------------------------------------------------------------
# This chunk imports input data and add the junction matrix to AnnData
# --------------------------------------------------------------------------------

# reticulate::repl_python()

# Import AnnData objects
adata_dic = {celltype: ad.read_h5ad(path) for celltype, path in r.adata_paths.items()}

# Import junction matrix
counts = pd.read_csv(r.mtx_path, sep=" ")

# Prep a function calculating junction length in Kb
def size_kb(coord):
    # Split the input coordinate. Assume the following format: 
    # "chr8:79611214:79616822:clu_1_+"
    parts = coord.split(":")
    start = int(parts[1])
    end = int(parts[2])
    # Calculate between the start and end sites in Kb
    distance = abs(end - start) / 1000
    return distance

for celltype in adata_dic.keys():
    # Retrieve an AnnData corresponding to the celltype
    ann = adata_dic[celltype]
    # Extract cell barcodes
    target_cells = list(ann.obs.index)
    # Slice the junction count matrix based on the extracted barcodes
    counts_subset = counts[target_cells]
    # Ensure that cell barcodes match between the count matrix and AnnData
    try: 
        # Add the raw junction count matrix to AnnData
        # NOTE: This requires barcode-by-junction as input
        ann.obsm['junctions_raw'] = counts_subset.T
        # Add log2-transformed junction matrix to AnnData
        ann.obsm['junctions_log2'] = np.log2(counts_subset.T + 1)
    except TypeError:
        print(f"Dimensions don't match between the two matrices for {celltype}!")

    # Calculate TPM
    # 1. Divide the read counts by the length of each gene in kilobases. This gives you reads 
    # per kilobase (RPK).
    # 2. Count up all the RPK values in a sample and divide this number by 1,000,000. This is 
    # your “per million” scaling factor.
    # 3. Divide the RPK values by the “per million” scaling factor. This gives you TPM.

    # Calculate the size of junctions
    length_list = [size_kb(c) for c in counts_subset.index]
    # Divide the raw counts by junction size, returning RPK
    counts_rpk = counts_subset.div(length_list, axis=0)
    # Calculate barcode-wise per million scaling factor
    per_barcode_million = counts_rpk.sum(axis=0) / 1_000_000
    # Convert into log2TPM scale with a pseudocount of 1
    log2tpm = np.log2(counts_rpk.div(per_barcode_million, axis=1) + 1)
    # Replace missing values with 1
    log2tpm = log2tpm.fillna(1)
    # Add log2TPM junctions to AnnData
    ann.obsm['junctions_log2TPM'] = log2tpm.T

    # Specify the path to updated AnnData
    updated_path = f"{r.out_dir}/{celltype}_JUNCTIONS.h5ad"
    # Save updated AnnData
    ann.write_h5ad(updated_path)

    # Replace the input AnnData with updated obj
    adata_dic[celltype] = ann

```

Input AnnData objects for each celltype:

```{r infile_info}

for (name in names(adata_paths)) {
    print(paste0(name, ": ", adata_paths[[name]]))
}

```

Refer to the following data added to the `AnnData` objects:

- `AnnData.obsm["junctions_raw"]`: raw junction counts
- `AnnData.obsm["junctions_log2"]`: log2-transformed raw junction counts with a pseudocount of 1
- `AnnData.obsm["junctions_log2TPM"]`: log2 + 1 transcripts per million (TPM)

Updated `AnnData` objects saved:

```{r outfile_info}

for (name in names(adata_paths)) {
    print(paste0(name, ": ", out_dir, "/", name, "_JUNCTIONS.h5ad"))
}

```

Input matrices are prepared as *log2 + 1 transcripts per million (TPM)* in the `SCA` object as shown below:

```{r prep_sca}

# --------------------------------------------------------------------------------
# This chunk builds an SCA obj. Refer to the following instructions:
# - https://rglab.github.io/MAST/reference/FromMatrix.html
# - https://rglab.github.io/MAST/articles/MAST-interoperability.html
# --------------------------------------------------------------------------------

# Extract metadata for all input cells
adata_meta <- map(py$adata_dic,
                  ~.x[['obs']] %>% rownames_to_column('barcode')) %>%
    bind_rows()
rownames(adata_meta) <- adata_meta[['barcode']]

# Ensure that the number of barcodes match between the matrix and metadata
if (nrow(adata_meta) != ncol(py$counts)) {
    stop("The number of barcodes is wrong!")
} else {
    # Reorder rows of the metadata 
    adata_meta <- adata_meta[colnames(py$counts), ]
}

# Prep feature table
feature_meta <- data.frame(junction=rownames(py$counts))

# Build an sca obj using raw counts
sca <- FromMatrix(as.matrix(py$counts),
                  cData=adata_meta,
                  fData=feature_meta,
                  check_sanity=FALSE)

# Clean assay slots to include both raw counts (counts) and log2 + 1 (et)
assays(sca)$counts <- assay(sca)

# Extract log2TPM-transformed counts from AnnData objects
l2t_mat <- map(py$adata_dic, ~.x$obsm[['junctions_log2TPM']]) %>%
    bind_rows() %>%
    t()

# Clean orders for row/column
l2t_mat <- l2t_mat[rownames(py$counts), colnames(py$counts)]

# Add the log2TPM matrix to SCA obj
assays(sca)$et <- l2t_mat

print(sca)
```

# Session info

```{r session_info, collapse=FALSE}
sessionInfo()
```



